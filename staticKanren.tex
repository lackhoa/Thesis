\section{staticKanren}\label{static}
This section introduces staticKanren, a language designed to analyze miniKanren programs. We first step through a few simple examples in section \ref{static_intro} to develop intuition for the detailed implementation in section \ref{static_imp}. Section \ref{S} and \ref{au} demonstrate some applications of the language.

\subsection{Introductory examples}\label{static_intro}
On the surface, staticKanren was designed to look as close to miniKanren as possible; however there are still some fundamental differences. Unlike miniKanren, staticKanren cannot deal with infinite answer streams. In fact, staticKanren programs can only return all answers using \code{run*} as there is no point withholding computed answers. As a result, we cannot write non-trivial recursive relations in staticKanren as-is. Looking on the bright side, this gives the language a simpler implementation.

staticKanren offers only three primitives constraints: equality, disequality and \textbf{lazy} constraint. The first two retain their syntax and semantics from miniKanren, whereas the third is a new addition to emulate recursive relations. There is no reason not to include more primitive constraints, the more knowledge staticKanren has, the better answers it can return. However, adding other constraints would be a distraction from our goal. Therefore, only disequality is implemented because it plays such an important role in relational programs.

In staticKanren, answers are also interpreted as programs. For that reason, the language must treat variable names more seriously. For example (in this section, $\Rightarrow$ means "evaluating under staticKanren"):


\begin{lstlisting}
(run* (q p) (== q 4))
\end{lstlisting}
$\Rightarrow$ \code{(((4 #(p 0)) () ()))}

If the program above were run under miniKanren instead, the answer would have been \code{((4 _.0))}. The variable \code{p} remains unknown in the answer, so it gets to keep its name (let us ignore the zero on the right for now). Besides the query variables, staticKanren always returns two additional constraint stores, one for disequalities and one for fake constraints. Hence, every answer has the same shape of a three-element list.  The next example demonstrates how the language deals with name shadowing:

\begin{lstlisting}
(run* (q a) (fresh (a d) (== q `(,a . ,d))))
\end{lstlisting}
$\Rightarrow$ \code{((((#(a 1) . #(d 1)) #(a 0)) () ()))}

The same program under miniKanren would return \code{(((_.0 . _.1) _.2))} instead. There are two variables having the same name \code{a}. staticKanren can still distinguish these two variables by their \textbf{birthdate} (the number shown on the right). Meanwhile, miniKanren sidesteps this problem completely by introducing a new name for every unbound variables used in the answer. It is perhaps a subjective matter to debate which representation is better, but there is one at least one theoretical problem avoided by the new approach\footnote{This example was even mentioned in one of the online miniKanren's Uncourse Hangouts organized by William Byrd.}:

\begin{lstlisting}
(run* (q p) (== q '_.0))
\end{lstlisting}
$\Rightarrow$ \code{(((_.0 #(p 0)) () ()))}

The same program under miniKanren would return \code{((_.0 _.0))}!. And because two Scheme symbols are the same iff they look the same, there is no way to distinguish \code{p} and \code{q} in that case, even from the computer's perspective. The last example demonstrates fake constraints. It is a silly program to stress that these fake constraints have no actual meaning, as the \code{fake} form does no more than evaluating its body and add the resulting expression to the fake constraint store.
\begin{lstlisting}
(run* (q p r) (fake `(mother ,q ,p)) (fake `(father ,p ,r))))
\end{lstlisting}

$\Rightarrow$
\begin{lstlisting}
(((#(q 0) #(p 0) #(r 0))
 ()
 ((father #(p 0) #(r 0)) (mother #(q 0) #(p 0)))))}
\end{lstlisting}



\subsection{Implementation}\label{static_imp}
This section presents an R6RS compliant implementation of staticKanren. We will highlight only those parts that demonstrates interesting differences from the standard miniKanren implementation describe by \textcite{byrdphd}\footnote{The full implementation is available at \url{https://github.com/lackhoa/staticKanren}.}.

The following functions construct and dispatch variables. Variables are vectors of two elements: its name (a symbol) and its birthdate (a number). Additionally, we would like to create a total order on the set of variables. A variable is prioritized over another if its birthdate is less (i.e. it was introduced sooner), or if it has the same birthdate and a lexicographically lesser name. We call prioritized variables \textbf{seniors} and less prioritized ones \textbf{juniors}.
\begin{lstlisting}
(;; name is a symbol, bd is a number
 define var (lambda (name bd) (vector name bd)))
(define var->name (lambda (var) (vector-ref var 0)))
(define var->bd (lambda (var) (vector-ref var 1)))
(define var? vector?)
(define var<?
  ;; v1 is prioritized over v2
  (lambda (v1 v2)
    (let ([n1 (symbol->string (var->name v1))] [bd1 (var->bd v1)]
          [n2 (symbol->string (var->name v2))] [bd2 (var->bd v2)])
      (or (< bd1 bd2)
          (and (= bd1 bd2) (string<? n1 n2))))))
\end{lstlisting}

Next we have definitions about constraints. Many of the functions could easily be defined automatically using record, but we use list to retain conceptual simplicity and flexibility. A constraint is a 4-tuple consisting of a substitution \code{S}, a date counter \code{C}, a disequality store \code{D} and a fake constraint store \code{F}. The counter starts from 0 and only goes upwards. Additionally, \code{letg@} is a special form to dispatch on states.
\begin{lstlisting}
(define all-constraints '(S C D F))
(define init-S '())
(define init-C 0)
(define init-D '())
(define init-F '())
(define make-c (lambda (S C D F) (list S C D F)))
(define init-c (make-c init-S init-C init-D init-F))
(define c->
  (lambda (c store)
    (rhs (assq store (map list all-constraints c)))))
(define update-S (lambda (c S) (letg@ (c : C D F) (make-c S C D F))))
(define update-C (lambda (c C) (letg@ (c : S D F) (make-c S C D F))))
(define update-D (lambda (c D) (letg@ (c : S C F) (make-c S C D F))))
(define update-F (lambda (c F) (letg@ (c : S C D) (make-c S C D F))))
\end{lstlisting}

The final piece of groundwork concerns the answer stream monad. Because there are no lazy streams, definitions are trivial to implement and we keep them here only for the sake of comparison.
\begin{lstlisting}
(define mzero (lambda () '()))
(define unit (lambda (x) `(,x)))
(define choice (lambda (x y) `(,x . ,y)))
(define mplus append)
(define bind (Î» (c* g) (apply mplus (map g c*))))
\end{lstlisting}

\code{unify} takes two terms along with a substitution and returns the extended substitution where these two terms are made the same. In the case that the two terms are always different, however, \code{unify} returns \code{#f}. There is a new clause in staticKanren to handle the case where both walked terms are variables, we make sure that seniors are always on the rhs. That way, walked seniors never result in juniors.
\begin{lstlisting}
(define unify
  (lambda (t1 t2 S)
    (let ([t1 (walk t1 S)]
          [t2 (walk t2 S)])
      (cond
       [(eq? t1 t2) S]
       [(and (var? t1) (var? t2))
        (or (and (var<? t2 t1)
                 (extend S t1 t2))
            (extend S t2 t1))]
       [(var? t1) (extend-check t1 t2 S)]
       [(var? t2) (extend-check t2 t1 S)]
       [(and (pair? t1) (pair? t2))
        (let ([S+ (unify (car t1) (car t2) S)])
          (and S+ (unify (cdr t1) (cdr t2) S+)))]
       [(equal? t1 t2) S]
       [else #f]))))
\end{lstlisting}

Now we are ready to define user-level functions, starting with fake constraint.
\begin{lstlisting}
(define fake
  (lambda (expr)
    (lambdag@ (c : F)
      (unit (update-F c `(,expr . ,F))))))
\end{lstlisting}

Next is \code{fresh}, a conjunction in the body of a \code{letv}. \code{letv} extracts the date counter from its input state and assign it to the new variables; the counter is then incremented in the resulting states.
\begin{lstlisting}
(define-syntax fresh
  (syntax-rules ()
    [(_ (x* ...) g g* ...)
     (letv (x* ...) (conj g g* ...))]))

(define-syntax letv
  (syntax-rules ()
    [(_ (x* ...) g)
     (lambdag@ (c : C)
       (let ([x* (var 'x* C)] ...)
         (g (update-C c (+ C 1)))))]))
\end{lstlisting}

The fascinating part is that reification can be made even simpler due to the fact that unknown variables get to keep their names. For the final result, \code{reify} only need to deep walk the query variables and the constraint stores in \code{S}. A more compact representation of the disequality store is then obtained by removing constraints that containing either no variable or irrelevant variable(s) (i.e. variable that does not occur in the final version of \code{q*} or \code{F}).
\begin{lstlisting}
(define reify
  ;; This will return a c with clausal S
  (lambda (c q*)
    (letg@ (c : S D F)
      (let ([t (walk* q* S)]
            [D (walk* D S)]
            [F (walk* F S)])
        (let ([R (get-vars `(,t ,F))])
          (let ([D (rem-subsumed (purify-D D R))])
            `(,t ,D ,F)))))))
\end{lstlisting}

For closure, helpers of \code{reify} are given below. It is worth noting that we treat constraint stores as normal miniKanren terms, which explains why the code is so short. Additionally, \code{case-term} is a macro form which helps dispatch on term. There are three cases for a term: variable, pair and atom. The cases are treated in that order.
\begin{lstlisting}
(define get-vars
  (lambda (t)
    (case-term t
      [v `(,v)]
      [(a d) (append (get-vars a) (get-vars d))]
      [a '()])))

(define purify-D
  (lambda (D R)
    (filter (lambda (d)
              (not (or (constant? d)
                       (has-iv? d R))))
            D)))

(define constant?
  (lambda (t)
    (case-term t
      [v #f]
      [(a d) (and (constant? a) (constant? d))]
      [atom #t])))

(define has-iv?
  (lambda (t R)
    (let has-iv? ([t t])
      (case-term t
        [v (not (memq v R))]
        [(a d) (or (has-iv? a) (has-iv? d))]
        [atom #f]))))
\end{lstlisting}

\subsection{Converting answer clausal form into  substitution}\label{S}
Let us begin exploring the practical value of staticKanren with a simple problem of returning substitutions instead of walked query variables in the answers. We achieve this with the new \code{run*su} form. Answers produced by \code{run*su} looks like this instead of \code{((_.0 _.0 _.0))}.
\begin{lstlisting}
(run*su (q p r) (== q p) (== p r))
\end{lstlisting}
$\Rightarrow$ \code{((((#(r 0) #(p 0)) (#(q 0) #(p 0))) () ()))}

We see that the answer looks exactly like the program, which in turns highlights a fundamental fact about states. miniKanren states are just accumulators of logical assertions given throughout execution of the program. By returning states as answers, we can summarize the content of the program. As a matter of fact, answers may be simpler than programs, as the following case shows.
\begin{lstlisting}
(pp (run*su (q p) (== q p) (== p q)))
\end{lstlisting}
$\Rightarrow$ \code{((((#(q 0) #(p 0))) () ()))}

Since \code{==} is commutative, the assertion \code{(== p q)} is redundant and it is removed from the final answer. It might look as if a complex inference mechanism is being used, but in fact this feature only requires a simple change to \code{run*}. Unification has already done much of the work building up a clean substitution, we only need to retrieve it back after it has been cleaned up even more by \code{reify}. Without further hand-waving, here is \code{run*su}.
\begin{lstlisting}
(define-syntax run*su
  ;; run* with substitutions
  (syntax-rules ()
    [(_ (q q* ...) g g* ...)
     (let ([q (var 'q init-C)] [q* (var 'q* init-C)] ...)
       (let ([qs `(,q ,q* ...)])
         (let ([c* ((conj g g* ... (finalize qs))
                    (update-C init-c (+ init-C 1)))])
           (map (lambda (c) (su c qs)) c*))))]))

(define su
  (lambda (c qs)
    `(,(unify (car c) qs init-S)
      .
      ,(cdr c))))
\end{lstlisting}

This much of development already lets us to obtain the "negative" side of the \code{lookupt} function defined in section \ref{reif}. However, we first need to redefine \code{lookupt} so that the recursive call is fake.
\begin{lstlisting}
(define lookupt
  (lambda (x env t)
    (lambda (bound?)
      (conde
       [Unchanged ...]
       [(fresh (y b rest)
          (== `((,y . ,b) . ,rest) env)
          (condo
           [Unchanged ...]
           [else
            (;; The only place that is changed
             fake `((lookupt ,x ,rest ,t) ,bound?))]))]))))
\end{lstlisting}

\begin{lstlisting}
(run*su (x env) ((lookupt x env 'unbound) #f))
\end{lstlisting}
$\Rightarrow$
\begin{lstlisting}
(((#(x 0) ()) 
  () 
  ())
 ((#(x 0) 
   ((#(y 1) . #(b 1)) . #(rest 1)))
  (((#(y 1) #(x 0))))
  (((lookupt #(x 0) #(rest 1) unbound) #f))))
\end{lstlisting}
This response is akin to the goal:
\begin{lstlisting}
(conde
 [(== '() x)]
 [(== `((,y . ,b) . ,rest) x)
  (=/= y x)
  ((lookupt x rest 'unbound) #f)])
\end{lstlisting}
The second clause is particularly interesting: it states that if the environment is non-empty and the look-up is to fail, then the variable \code{x} must not match the association's lhs and the look-up must also fail for the rest of the environment.

\subsection{Analyzing common unification pattern with anti-unification}\label{au}
There are still cases where the answers returned do not look at all similar to the program that generated them. Take \code{membero} for example:
\begin{lstlisting}
(define membero
  (lambda (x ees)
    (fresh (e es)
      (== ees `(,e . ,es))
      (condo
       [(==t x e) succeed]
       [else (fake `(membero ,x ,es))]))))
\end{lstlisting}

Rewritten through \code{run*su}, this gives.
\begin{lstlisting}
((((#(ees 0) (#(x 0) . #(es 1)))) 
  ()
  ())
 (((#(ees 0) (#(e 1) . #(es 1))))
  (((#(e 1) #(x 0))))
  ((membero #(x 0) #(es 1)))))
\end{lstlisting}
Which is equivalent to this program.
\begin{lstlisting}
(define membero
  (lambda (x ees)
    (conde
     [(fresh (es) (== `(,x . ,es) ees))]
     [(fresh (e es)
        (== `(,e . ,es) ees)
        (=/= e x)
        (membero x es))])))
\end{lstlisting}
Human readers would agree that this version does not look at all natural: it does not show the common structure of \code{ees} in both clauses. To make this notion of commonness more clear, we refer to \textbf{anti-unification}, which as the name suggests is a dual of unification. Given a collection of terms, anti-unification returns their least general generalization. This process describes quite well humans' ability to recognize pattern over symbolic formulae, which is exactly what we need for the purpose. For example,
\begin{lstlisting}
(let ([t* '((1 * 2 = 2 + 1)
            (4 * 3 = 3 + 4))])
  (anti-unify t*))
\end{lstlisting}
$\Rightarrow$ \code{(#(au0 0.5) * #(au1 0.5) = #(au1 0.5) + #(au0 0.5))}

Anti-unification has captured the common pattern from these two formulae. \code{au0} and \code{au1} are normal staticKanren variables introduced in the process, which from now on we shall refer to as \textbf{pattern variables}. All pattern variables have the birthdate \code{0.5}, the reason for which will become clear when the program is complete.

The implementation of \code{anti-unify} is adapted from \textcite{ostvold2004functional}. The biggest difference is that this version also recognizes identical variables as being the same terms and reuse that variable in the pattern. 

\begin{lstlisting}
(define anti-unify
  (lambda (t*)
    (let-values
        ([(res _iS)
          (let au ([t* t*] [iS '()])
            (cond
             [;; rule 7: eq? deal with variables as well
              ;; hence, it would not introduce useless new vars
              (for-all (eqp? (car t*)) (cdr t*))
              (values (car t*) iS)]
             [;; rule 8
              (for-all pair? t*)
              (let-values ([(a iS+) (au (map car t*) iS)])
                (let-values ([(d iS++)
                              (au (map cdr t*) iS+)])
                  (values `(,a . ,d) iS++)))]
             [;; rule 9
              (find (lambda (s) (teq? (lhs s) t*)) iS)
              =>
              (lambda (s) (values (rhs s) iS))]
             [;; rule 10
              else
              (let ([new-var
                     (var (au-name (length iS)) AU-BD)])
                (values new-var (extend iS t* new-var)))]))])
      res)))

(define eqp? (lambda (u) (lambda (v) (eq? u v))))

(define AU-BD (+ init-C 0.5))

(define au-name
  (lambda (n)
    (string->symbol (string-append "au" (number->string n)))))
\end{lstlisting}

Anti-unification is the heart of our solution, but the way to victory is not laid out just yet. It is not clear how to convert the obtained pattern into a usable program. We start by making a small step just like in section \ref{S}.
\begin{lstlisting}
(define-syntax run*au
  ;; run* with anti-unification analysis
  (syntax-rules ()
    [(_ (q q* ...) g g* ...)
     (let ([q (var 'q init-C)] [q* (var 'q* init-C)] ...)
       (let ([qs `(,q ,q* ...)])
         (let ([c* ((conj g g* ... (finalize qs))
                    (update-C init-c (+ init-C 1)))])
           (au-extract c* qs))))]))
\end{lstlisting}

The main work is now delegated to \code{au-extract}, which takes the answers and the query variables as input. First, \code{au-extract} takes the answer terms \code{t*} and extracts a common pattern \code{au}. Second, it unifies the queries variables with \code{au} in the empty environment, resulting in the substitution \code{uS}. The next obvious step is to unify \code{au} back into each of the answer term in \code{t*} to obtain the substitutions \code{S*}. Finally, we clean up the substitutions with \code{purify-S} and walk the other constraints in those substitutions.
\begin{lstlisting}
(define au-extract
  (lambda (c* qs)
    (let ([t* (map car c*)]
          [D* (map cadr c*)]
          [F* (map caddr c*)])
      (let ([au (anti-unify t*)])
        (let ([auS (unify qs au init-S)])
          (let ([S* (map (lambda (t) (prefix-unify au t auS))
                         t*)])
            `(,(purify-S auS init-C)
              ,(map au-helper S* D* F*))))))))

(define prefix-unify
  (lambda (t1 t2 S) (prefix-S (unify t1 t2 S) S)))

(define au-helper
  (lambda (S D F)
    (let ([S (purify-S S AU-BD)]
          [D (walk* D S)]
          [F (walk* F S)])
      `(,S ,D ,F))))
\end{lstlisting}

The only question left is how to clean up the substitutions. We have already done this before with the help of \code{walk*}, but this time things are not so convenient because we also want to retain the intermediate associations with the anti-unification patterns. There is a first principle which seems to work well: An association is redundant iff it is a rename (an association whose rhs is a variable) whose lhs has not yet been introduced yet. This is because we can just use the rhs without having to ever introduce the lhs. Conveniently, \code{purify-S} can keep track of already introduced variables using their birthdates.
\begin{lstlisting}
(define purify-S
  (lambda (S date)
    (filter (lambda (s) (<= (var->bd (lhs s)) date))
            S)))
\end{lstlisting}

This should also explain why pattern variables are born on \code{0.5}: they are introduced after query variables, but before any other variable introduced by the user. With the complete implementation, we can start using \code{run*au} to rewrite programs. The call below will return \code{lookupo}, obtained by forcing \code{lookupt} to return \code{#t}. Notice that the recursive call of \code{lookupt} has been replaced by a fake one just like in the previous section.
\begin{lstlisting}
(run*au (x env t) ((lookupt x env t) #t))
\end{lstlisting}
$\Rightarrow$
\begin{lstlisting}
(((#(env 0) 
   ((#(au0 0.5) . #(au1 0.5)) . #(rest 1))))
 ((((#(au1 0.5) (val . #(t 0)))
    (#(au0 0.5) #(x 0)))
   ()
   ())
  (((#(t 0)
     (closure
      #(lam-expr 2)
      ((#(x 0) rec . #(lam-expr 2)) . #(rest 1))))
    (#(au1 0.5) (rec . #(lam-expr 2)))
    (#(au0 0.5) #(x 0)))
   ()
   ())
  (() 
   (((#(au0 0.5) #(x 0))))
   (((lookupt #(x 0) #(rest 1) #(t 0)) #t)))))
\end{lstlisting}
This response is akin to the goal:
\begin{lstlisting}
(fresh (au0 au1)
  (== `((,au0 . ,au1) . ,rest) env)
  (conde
   [(== au0 x) (== `(val . ,t) au1)]
   [(== au0 x)
    (== au1 `(rec . ,lam-expr))
    (== `(closure
         ,lam-expr
         ((,x . (rec . ,lam-expr)) . ,rest))
       t)]
   [(=/= au0 x)
    ((lookupt x rest t) #t)]))
\end{lstlisting}
Anti-unification identifies that across all clauses, the environment is always a non-empty list with the first element being an association. It also correctly handles how each clause has to do afterwards to obtain the original semantics. Especially the third clause is a clever assertion: it says that if the association's lhs (\code{au0}) is different from the variable \code{x} and the look-up is to succeed, then the look-up of \code{x} in the tail of the environment has to succeed.