\section{Introduction}
Many problems, especially logic puzzles such as \textit{"knights and knaves"} (\cite{knight}) demand the consideration of many different possibilities. There many different techniques to do this, each with its own set of trade-offs, but they are all generalized by the term \textbf{backtracking}. \textbf{Logic programming languages} offer to make backtracking implicit; programmers only need to declare the rules, and the computer will automatically generate all states consistent within those rules. Logic languages often give elegant solutions to a wide class of problems involving search and enumeration because the backtracking mechanism is hidden.

Logic programming dates back to 1972, when Prolog (\textbf{pro}grammation en \textbf{log}ique) was first invented by Alain Colmerauer and Phillipe Roussel (\cite{early-prolog}). At the time of its birth, logic programming was considered by some to be the future, especially in Japan. In the 1970's, the Japanese International Trade and Industry (MITI) wanted to take over the computer industry with a new Fifth Generation Computing System Project (named ICOT), aiming to replace conventional algorithmic computing with constraint-based programming techniques. The project soon failed, however, because these languages were not fast enough to compete with other mainstream object-oriented languages such as Java and C\#. Carl Hewitt summed up the situation by the comment "\textit{Computation is not subsumed by deduction.}" (\cite{logic-fail}.)

Despite its name, Prolog was not just about logic and its users generally do not shy away from its extra-logical features. These features on one hand can greatly enhance performance, but they can also make programs less declarative, incomplete and even unsound. On the other hand, \textbf{relational programming} is a discipline of logic programming in which these features are left out. This guarantees that all answers are returned even when all arguments are logic variables. Additionally, the same set of answers are returned regardless of the order in which rules are applied. The design philosophy of \textbf{miniKanren} puts great emphasis on this discipline\footnote{"Kanren" is literally Japanese for "relation".}. (\cite{byrdphd}.)

Technically speaking, miniKanren is not a language with its own compiler or interpreter; it is instead a family of languages embedded in a great variety of other host languages. This paper uses the Scheme implementation since it is the canonical version mentioned in almost every research paper written on the language. Also, Scheme's macro makes the syntax less clunky and more natural to read and write. Last but not least, Scheme is an extremely elegant language with minimal syntax (some would even say no syntax), hence it is trivial to briefly specify a small portion of the language to be used in this text.

\ifthesis This paper presents a way of automatically writing negative relations in miniKanren.
\else Firewalls are very important for the security of organizations. However, undocumented firewall rules are not easy to understand and test. For that purpose, this paper presents a firewall analysis assistant in miniKanren. Much work has actually been done on the subject, the most similar to mine was done by Eeronent and Zitting (\cite{Eronen2001AnES}). Their software is written in Prolog and is much more complex than the approach in this report.\fi

The layout of this paper is as follow: Section \ref{prelim} specifies a subset of Scheme and gives a brief introduction to the syntax and semantics of miniKanren.
\ifthesis Section ... proposes a way of automatically writing negation in miniKanren.
\else Section ... introduces a prototype of a firewall analysis assistant in miniKanren.\fi