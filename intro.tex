\section{Introduction}

To begin, let us take a look at a particular logic puzzle:

{\small\textit{"On a certain fictional island there are only two types of inhabitants: the knights always tell the truth, and the knaves who always tell lies. One day, a logician pays a visit to a small family of three on the island. While the four are having dinner, the logician asks whether the dad is a knight or a knave. The dad says "Ask my son and he will tell you the truth". The son then says "We are all of the same type". Finally, the mom says "You have to excuse us, one of them cannot tell the truth". Can you tell which family members are knight, and which are knaves?"}}

If the dad is telling the truth, then the son's statement is true and so the entire family are knights. However, that must mean the mom is also telling the truth, and they cannot all be knights (a contradiction). Therefore, the dad must be lying, and so is the son. Following from the son's lie it must be the case that the family has both types of people. Since two family members are already determined to be knaves, the mom must be a knight.

What if we start first from the mom? Suppose she is telling lies, then both the son and dad are telling the truth. However, the son's statement must be wrong since the family is mixed (a contradiction). Therefore, the mom must be telling the truth, and either the dad or the son is lying (or both). If the son is telling the truth, then it immediately follows he is lying, since according to him the dad must be telling the truth and the mom's statement now cannot be true. Therefore, the son is lying and so is the dad for referring to him. This conclusion is consistent with the first approach.

This type of logic puzzle was popularized by (\cite{knight}). In the solving of the puzzle, we can see a relatively simple mechanism in action. First, determine one possible value of an unknown variable (if there is none left, abandon the branch). Second, check if the state is logically consistent; if yes, loop back to the first step; if no, undo the choice made in the first step, choose something else, and carry on with the algorithm. The process terminates either when there is no longer any choice to be made, in which case we can output the answer, or when we have exhausted all possibilities and no choice can lead to a consistent state.

Every time a person wants to roll out a program to solve a puzzle of similar kinds, they need to not only specify the problem, but also write the backtracking algorithm as well. After a while, one would wish that the second part of the task -- having little to do with the problem -- should be standardized (and optimized) by some sort of framework, so that only the problem needs to be defined. \textbf{Logic programming} promises to make this job easier for those people (and hopefully for everyone else as well). Using a language of this kind, the programmer only needs to declare rules, and the computer will give them back all states consistent within those rules. One such language which will be discussed in this text is \textbf{miniKanren}.

miniKanren is neither the only or the first logic programming language. The idea dates back to 1972, when Prolog was first invented by Alain Colmerauer and Phillipe Roussel. The name Prolog was an abbreviation for \textbf{pro}grammation en \textbf{log}ique. Despite the name, Prolog users generally do not shy away from its extra-logical features. These features on one hand can enhance greatly performance, but they can also make programs less declarative, incomplete and even unsound. (\cite{early-prolog})

Prolog was once considered the future of computing, at least in Europe and especially in Japan. In the 1970's, the Japanese International Trade and Industry (MITI) wanted to take over the computer industry with a new Fifth Generation Computing System Project (named ICOT). The project failed, however, because the language was not fast enough to compete with other mainstream object-oriented languages like Java and C\#. Carl Hewitt summed it up nicely with: "\textit{Computation is not subsumed by deduction.}" (\cite{logic-fail})

In this paper we do not talk about performance, but instead focus on the logic. Relational programming is a discipline of logic programming whereby extra-logical features that provide unsound behavior are not used. This guarantees that all answers are returned even when non of the arguments are grounded. The design philosophy of miniKanren puts great emphasis on this discipline\footnote{"Kanren" is literally Japanese for "relation".}. (\cite{byrdphd})

miniKanren does not have its own interpreter, but is embedded in a larger programming language. One such language -- which we will use in this paper -- is Scheme. Scheme is our implementation of choice for three reasons. The first reason is that it is the canonical version mentioned in almost every academic paper written on the language. The second reason is that Scheme's macro makes the syntax less clunky and more natural to read and write. Last but not least, Scheme is an extremely elegant language with minimal syntax (some would even say no syntax), hence it is trivial to briefly specify a small portion of the language to be used in this text.

The layout of this paper is as follow: Section ... will specify a subset of Scheme. Section ... discusses miniKanren. Finally, a firewall design assistant -- one of the main real-world application in this paper -- is given in section ....