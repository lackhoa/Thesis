\section{Introduction}
Many problems, especially logic puzzles such as "knights and knaves" (\cite{knight}) put heavy emphasis on enumeration and search. Programs to solve these problems can involve different techniques, generalized under the term \textbf{backtracking}. Logic programming offer to make backtracking implicit; programmers only need to declare the rules, and the computer will automatically generate all states consistent within those rules. Logic languages often give elegant solutions to a wide class of problems, some can be also used in general computation.

Logic programming dates back to 1972, when Prolog (\textbf{pro}grammation en \textbf{log}ique) was first invented by Alain Colmerauer and Phillipe Roussel (\cite{early-prolog}). At the time of its birth, logic programming was considered by some to be the future, especially in Japan. In the 1970's, the Japanese International Trade and Industry (MITI) wanted to take over the computer industry with a new Fifth Generation Computing System Project (named ICOT), aiming to replace conventional algorithmic computing with constraint-based programming techniques. The project soon failed, however, because these languages were not fast enough to compete with other mainstream object-oriented languages such as Java and C\#. Carl Hewitt summed up the situation by the comment "\textit{Computation is not subsumed by deduction.}" (\cite{logic-fail}.)

Despite its name, Prolog was not just about logic and its users generally do not shy away from its extra-logical features. These features on one hand can greatly enhance performance, but they can also make programs less declarative, incomplete and even unsound. On the other hand, \textbf{relational programming} is a discipline of logic programming in which these features are left out. This guarantees that all answers are returned even when all arguments are logic variables. Additionally, the same set of answers are returned regardless of the order in which rules are applied. The design philosophy of \textbf{miniKanren} puts great emphasis on this discipline\footnote{"Kanren" is literally Japanese for "relation".}. (\cite{byrdphd}.)

Technically speaking, miniKanren is not a language with its own compiler or interpreter. It is instead a family of languages embedded in a great variety of other host languages. This paper uses the Scheme implementation since it is the canonical version mentioned in almost every research paper written on the language. Also, Scheme's macro makes the syntax less clunky and more natural to read and write, which helps keep the paper short.

\ifthesis This thesis aims to provide frameworks and techniques for writing conditionals in miniKanren as well as a way to analyze the correctness of many pre-existing miniKanren programs using conditionals.
\else Firewalls are very important for the security of organizations. However, undocumented firewall rules are not easy to understand and test. For that purpose, this paper presents a firewall analysis assistant in miniKanren. Much work has actually been done on the subject, the most similar to mine was done by Eeronent and Zitting (\cite{Eronen2001AnES}). Their software is written in Prolog and is much more complex than the approach in this report.\fi

The layout of this paper is as follow: Section \ref{prelim} gives a brief introduction to the syntax and semantics of miniKanren.
\ifthesis Section \ref{reif} defines conditionals using pseudo-functions and demonstrates their use in miniKanren. Section \ref{static} introduces staticKanren, its implementation and its applications related to conditionals.
\else Section \ref{firewall} introduces a prototype of a firewall analysis assistant in miniKanren.\fi