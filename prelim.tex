\section{Preliminaries}
\label{prelim}
Scheme is not a particularly pleasant language to read on paper.
Readers who wish to understand the code are strongly advised to copy it to a code editor with parentheses highlighting support such as emacs.

\subsection{A subset of Scheme}
This section describes a functional (as opposed to imperative) subset of Scheme needed for miniKanren. Note that this is not the same as the subset needed for the implementation of miniKanren, although such implementation is very plausible to code.
Readers who wish to learn more about the complete language or see more examples can refer to to (\cite{tspl4}) and (\cite{sicp}).

\textbf{Symbol} is the simplest data type in the language. For example, \code{a}, \code{b}, \code{xyz} are all representations of symbols.
A symbol is like an atomic idea, it has meaning only when compared with other symbols. That is, the only thing we can say about \code{x} and \code{xy} is that they are different from each other. The fact that \code{x} is the prefix of \code{xy} is never recognized by the language.

Because of that, we can hardly do anything useful with symbols, since individual symbols can neither be taken apart, nor can two symbols ever be concatenated to create a new one. To represent structures, we need \textbf{pairs}.

In Lisp, \textbf{pair} is the most basic structure from which all other tree structure can be derived.
For that reason, this is the only data structure mentioned in this paper.
A pair is specified by two parts: its \textbf{car} (the left element) and \textbf{cdr} (the right element).

From pairs we can make up lists. A list can either be \textbf{null} \textbf{empty} (written as "\code{()}") or a pair of a thing \code{a} and another list \code{d}.

We have not shown how to write a pair, because the way Lisp handles pairs is slightly confusing. The mathematically correct way to write a pair with car \code{a} and cdr \code{d} is simply \code{(a . d)} (or sometimes \code{[a . d]}).
However, doing so would be very tedious for bigger trees, so there is a simple rule that if \code{d} is also a pair, we can remove the dot and the parentheses surrounding \code{d}. More concretely, \code{(a . (b . d))} $\Rightarrow$ \code{(a b . d)}.
For example, a list of all natural numbers from 1 to 3 can be reduced from \code{(1 . (2 . (3 . ()))} to \code{(1 2 . (3 . ()))} and finally to just \code{(1 2 3)}. In fact, it is possible to visually recognized a list as "something surrounded by parentheses/brackets and has no dot". Explanation to why this is true is left as an exercise.

In the context of lists, it is sometimes helpful to think of car as the first element of the list, and cdr as the rest of the list, although such analogy might backfire in certain situations.

Equipped with just these two data types, we are now ready to learn how Scheme can be interpreted. \textcite{lisp} gives the mathematical description of Lisp; a meta-circular evaluator is also given in (\cite{lisp-man}).
Listing \ref{evaluator} is the source code of a Scheme interpreter -- only for our specific usage -- written in a pseudo programming language. This meta-language is comparable to Python, but with additional features like "magical" pattern matching, Lisp-style list, and tail recursion. Note that literal symbols are enclosed in quotation marks (") to distinguish them from identifiers of the meta-language.

Although incomplete, the evaluator should describe most programs used in this paper. Two functions are most critical -- \code{eval} and \code{apply} -- which perpetually call each other until \code{eval} hits a base case and returns the output expression (or the program just loops forever). \code{eval} takes the input expression \code{exp}, along with the environment \code{env} which maps identifiers to their values, and returns the interpreted value. The behavior of \code{apply} will be given below.

\input{code/meta-eval}
Below is a comprehensive list of every type of expression encountered by \code{eval} and its corresponding action:
\begin{itemize}
\item Symbol: look for its value in the environment and return the result.
\item Lambda: returns a closure with the content specified by the lambda.
\item Quotation ('): returns the expression being quoted.
\item Quasi-quotation (`): returns the expression being quasi-quoted, except for those sub-expressions preceded with a comma (,). This interpretation is slightly incorrect since the real language allows nested quasi-quotation. However, such nesting only becomes useful when writing macros and thus will not bother us.
\item Define: out of all cases, \code{define} is the only one that does not return a value; we say that it is only evaluated for side-effect. For we seek to write code in a functional manner,  \code{define} is only used to create functions and constants which have global meaning, never to mutate local variables. 
\item Application: this is the standard case, \code{apply} just calls \code{eval} after it extending \code{procedure}'s environment by mapping its formal parameters to \code{args}. Note that the new evaluation is done in the extended environment of \code{procedure} and not the original call to \code{eval}, giving the language lexical scope instead of dynamic scope.
\end{itemize}

From here on out, we write "\code{e1} $\Rightarrow$ \code{e2}" to mean that the result of calling \code{eval(e1, global-env)} is \code{e2}. Again, \code{global-env} is purely a dictionary for functions defined throughout the paper. On an interesting note, to interpret pure lambda calculus (the subset needed for Turing-completeness), one only has to remove all but the first, second and last case of \code{eval}.

For readers that have never seen a Lisp's meta-circular evaluator: the above code would look almost identical had it been written in Scheme instead. It certainly would be a better choice to explain Scheme using itself, but then that would not be an explanation anymore. With this subset of the language specified, we have covered the groundwork necessary to introduce miniKanren.
\subsection{miniKanren}
Due to time constraints, this \ifthesis thesis \else report \fi will not cover miniKanren in as much detail as done with Scheme.
An introduction to the language is presented in \cite{reasoned}.
\textcite{byrdphd} gives an excellent dissertation on the implementation details and applications of the language.
For a more focused and concise treatment of logic programming in Scheme, consider microKanren (\cite{micro}).
Additionally, the website (\cite{mkdotorg}) keeps up with the latest implementations of the language and other related resources.

As mentioned earlier miniKanren is not a separate programming language but a structure inside of a language (in our case, Scheme). The language's components from the low-level perspective include:
\begin{itemize}
\item \textbf{Logic variables} These are very different from naming variables. Unbound naming variables always mean that an error has occurred. In contrast, unbound logic variables are perfectly valid. From here on, variable means logic variable unless stated otherwise.
\item \textbf{Streams} (\cite{sicp}) Although we do not have to worry about streams in our daily miniKanren usage, knowing what a stream is helps us know what is going on when the program diverges (loops forever). Streams are simply lazy lists which will yield values only when we ask for them. Because of this laziness, we can represent an infinite number of computational branches without using unlimited computational resources.
\item \textbf{States} (also \textbf{packages}) States are the most important ingredient, representing all assertions made by the program at any given time.
\item \textbf{Goal} A goal is a function (a normal Scheme function) that maps a state to a stream of states. Goals should only be created by \textbf{goal constructors}, as will be described in the following sections.
\item \textbf{Relation} Relations are simply Scheme functions that return goals.
\item \textbf{Program}: A miniKanren program consists a goal wrapped inside of a \code{run} form which, with the help of zero or more relation definitions, outputs list of \textit{state representations}. We will talk about \code{run} pretty soon.
\end{itemize}

However, we can also analyze the language from a high-level point of view (which is often more helpful) in terms of its primitives, its means of combination, and its means of abstraction (\cite[359]{sicp}). miniKanren's primitives are logical constraints (like \code{==}, \code{=/=}, etc.) and a special form to create and bind new logic variables (\code{fresh}). Its two means of combination are conjunction (\code{conj}) and disjunction (\code{conde}). Finally, its only means of abstraction is relation.

We cannot continue further without mentioning \code{run}, since it is the only tool we have to make sense of miniKanren's results. To do this, \code{run} catches the stream produced by the goal and turns it into a list of specified length. In the process, it also converts the packages inside into a more readable format -- a process called \textbf{reification} -- which also highlights the values of the \textit{query variables}. We will not describe precisely what the format produced by reification is, but it should be intuitively grasped as we introduce more examples. Meanwhile, readers need only know that \code{run} has the following syntax:
\lstset{language=Scheme, showstringspaces=false, breaklines=true}
\begin{lstlisting}
(run <answer-count> (<query-var-1> <query-var-2> ...) <goal>)
\end{lstlisting}

Additionally, users can use this form to get back all answers:
\begin{lstlisting}
(run* (<query-var-1> <query-var-2> ...) <goal>)
\end{lstlisting}

The first goal constructor (primitive constraint) to learn about is \code{==}.
Simply put, \code{==} unifies (makes the same) two terms, and declarively it means "these two shall be equal". More precisely, \code{==} receives a package and returns a stream. This stream can either contain one state where the two terms become their most general unifier (mgu), or be empty when they cannot be unified.

Actually, \code{==} is the only \textit{constraint} in the what is called the "core" of miniKanren. The reason is that even with only this constraint, the language is already Turing-complete. However, none but the simplest programs can be written conveniently using \code{==}.

The concept of unification has its roots in predicate logic. The terms of predicate logic can be represented in Scheme by the following rules:
\begin{itemize}
\item Variables are logic variables.
\item For function expressions of the kind $f(t_1,...,t_n)$, we move $f$ to the inside of the parentheses; and recursively translate each argument $t_i$ to \code{g\_i}, resulting in the expression \code{(f g\_1,...,g\_n)}.
\end{itemize}

Hence, all terms of predicate logic can be broken down to just symbols and lists. This simpler representation has two important advantages over the more traditional representation of Prolog. First, we can omit arguments, writing terms like \code{(f x . y)} and later unify it with \code{(f 1 2 3)} to get \code{x = 1} and \code{y = (2 3)}. Second, users don't need to wonder about when to use predicates and when to use pairs/lists\footnote{Usage of predicates are more efficient, however, especially when the number of arguments are known. The reason is that predicates are smaller and their arguments may be indexed.}.

Below are some example usage of \code{==}.
\begin{lstlisting}
(run* (q)
  (== 'x 'x))
\end{lstlisting}
$\Rightarrow$ \code{(\_.0)}

\begin{lstlisting}
(run* (q)
  (== '(x y) '(x y)))
\end{lstlisting}
$\Rightarrow$ \code{(\_.0)}

\begin{lstlisting}
(run* (q)
  (== 'x 'y))
\end{lstlisting}
$\Rightarrow$ \code{()}

In the first and second example, the two arguments to \code{==} are already equal, hence the program returns one successful answer. In the third example, the two terms \code{x} and \code{y} can never be unified and the program returns the empty list indicating that there is no possible answer.

This usage of \code{==} is the same as term comparison, returning one state when the terms are equal and no state otherwise. When variables are involved, the role of \code{==} becomes a lot more interesting as it also doubles the job as a pattern matcher.

To make logic variables, we must use the goal constructor (fresh variable creator) \code{fresh}. \code{fresh} is perhaps the most complex goal constructor in miniKanren, partly because it is also a special syntactic form. Operationally, \code{fresh} creates one or more fresh logic variables. Syntactically, \code{fresh} also bind these newly created variables to Scheme identifiers within its body.

Let us take a look at some examples.

\begin{lstlisting}
(run* (q)
  (fresh (v)
    (== v 'x)
    (== q v)))
\end{lstlisting}
$\Rightarrow$ \code{(x)}

\begin{lstlisting}
(run* (q)
  (fresh (v u)
    (== v 'x)
    (== u v)
    (== q u)))
\end{lstlisting}
$\Rightarrow$ \code{(x)}

The first program introduces a new logic variable \code{v}, which is then unified with both the symbol \code{x} and the query variable \code{q} (the order does not matter). The only answer returned is the value of \code{q}, which is the symbol \code{x}.

In the second program, two variables are introduced. Since \code{u} is unified with \code{v} and the rest of the program is the same, the answer is also the same.

We cannot refer to a logic variable not introduced by, or not in the body of \code{fresh}. For example, this call fails.
\begin{lstlisting}
(run* (q)
  (fresh (v)
    (== q v)  ; Perfectly fine
    (== q u)  ; Error: variable u is unbound
  )
  (== q v)  ; Error: variable v is unbound
)
\end{lstlisting}
Note that the "variables" mentioned in the error messages are actually naming variables, not logic variables. Technically speaking, logic variables need not have names. When we talk about "the variable \code{v}", we actually mean "the logic variable bound to the naming variable \code{v}". We will look at one last example showcasing \code{fresh}'s lexical scope.
\begin{lstlisting}
(run* (q)
  (fresh (v)
    (== v 'x)
    (== q v)  ; v bound to the symbol x
    (fresh (v)
      (== v 'y)
      (== q v)  ; v bound to the symbol y
      )))
\end{lstlisting}
$\Rightarrow$ \code{()}
This call fails because \code{q} was unified to two logic variables having two different values but are bound to the same name \code{v}. The first \code{v} is introduced by the outer \code{fresh}, the second \code{v} is introduced by the inner \code{fresh} and it \textit{shadows} the outer \code{v}. Although shadowing seems to be a very confusing thing in this example, it is actually very useful especially when programs grow bigger.

For a reason that will become apparent up later, it is important to demystify the answer format returned by miniKanren (more precisely, by \code{run}). First, unknown variables declared to be the same (e.g. by \code{==}) always have the same index, for instance:
\begin{lstlisting}
(run* (p q r) (== p q))
\end{lstlisting}
$\Rightarrow$ \code{((\_.0 \_.0 \_.1))}

Second, if a variable is tied to a value then the value will be used instead of the form \code{\_.n}. Furthermore, if a variable is sure to be a pair then that fact is also made known in the answer, for example:
\begin{lstlisting}
(run* (q) (fresh (x y) (== `(,x ,y) q)))
\end{lstlisting}
$\Rightarrow$ \code{((\_.0 \_.1))}

A simple principle to keep in mind is that \textit{information must be preserved during reification}. The only lost information, however, are the names of the logic variables. The reason is due to the name shadowing phenomenon mentioned earlier. That is, if we had chosen to represent unknown variables by their names, then there would be no way of telling whether two variables were really declared to have the same value or they just happen to bear the same name.

Next, we take a look at the goal constructor (goal disjunction combinator) \code{conde}.
If one needs to point out exactly one thing that makes logic programming seem magical, disjunction would be a good answer. Every example we have seen returns either zero or one answer. With \code{conde}, we can start returning two or more answers. The \code{conde} form consists of a number of \textbf{clauses}, each contain a number of goals, for example:

\begin{lstlisting}
(run* (q)
  (conde
    [(== 'x q)]
    [(== 'y q)]))
\end{lstlisting}
$\Rightarrow$ \code{((x y))}

As promised, this program actually returns two answers. We can view \code{conde} as creating two "parallel universes" where \code{q} is unified with \code{x} in the first and \code{y} in the second.

The final remaining goal constructor (goal conjunction combinator) of core miniKanren is \code{conj}. \code{conj} represents logical conjunction, and is only made explicit in microKanren. We have actually encountered \code{conj} a lot in previous examples. Intuitively, \code{conj} is called whenever two or more goals are written in series in \code{run}, \code{fresh} or \code{conde}. Each of the examples below returns \code{()}.
\begin{lstlisting}
(run* (q)
  (conde
    [(== 'x q) (== 'y q)]))
\end{lstlisting}

\begin{lstlisting}
(run* (q)
  (== 'x q)
  (== 'y q))
\end{lstlisting}

\begin{lstlisting}
(run* (q)
  (fresh ()
    (== 'x q)
    (== 'y q)))
\end{lstlisting}

The introduction of miniKanren's core should be complete with \code{==}, \code{fresh}, \code{conde} and \code{conj}. However, we will also take a look at the most important additional constraint \code{=/=}. As the name suggest, \code{=/=} declares \textit{disequality} of two miniKanren terms:
\begin{lstlisting}
(run* (q) (=/= 5 q))
\end{lstlisting}
$\Rightarrow$ \code{((\_.0 (=/= ((\_.0 5)))))}

The program above returns one answer, stating that while \code{q} is unknown, it is must not be made equivalent to \code{5}. If we happens to do that, the program fails:
\begin{lstlisting}
(run* (q) (=/= 5 q) (== q 5))
\end{lstlisting}
$\Rightarrow$ \code{()}

To better understand answers containing disequalities, a more complex example is needed:
\begin{lstlisting}
(run* (q p r) (=/= `(,q ,p) `(1 2)) (=/= p r))
\end{lstlisting}
$\Rightarrow$ \code{(((\_.0 \_.1 \_.2) (=/= ((\_.0 1) (\_.1 2)) ((\_.1 \_.2)))))}

We see that the disequality constraint store is simply a list of mini anti-substitution lists. Each substitution list in turns contains disassociations of the form \code{(x v)} where \code{x} must be a variable. In plain English, the answer above says that \code{p} is different from \code{r} and that either \code{q} must be different from \code{1} or \code{p} must be different from \code{2}.