\section{Relational conditionals with pseudo-functions}\label{reif}
\subsection{The problem with conde}
Suppose we need to write a relation called \code{lookupo} to retrieve a variable's value in an environment. The task at first is just a straightforward transformation from the Scheme function \code{lookup}.
\begin{lstlisting}
(define lookup
  (lambda (x env)
    (let ([a (car env)])
      (cond
       [(eq? x (lhs a)) (rhs a)]
       [else (lookup x (cdr env))]))))

(define lookupo
  (lambda (x env t)
    (fresh (y b rest)
      (== `((,y ,b) . ,rest) env)
      (conde
       [(== y x) (== b t)]
       [(=/= y x) (lookupo x rest t)]))))
\end{lstlisting}

Later on we might need to actually handle the case where the variable is unbound instead of raising an error or fail. We update both definitions:
\begin{lstlisting}
(define lookup
  (lambda (x env)
    (cond
     [(null? env) #f]
     [else
      (let ([a (car env)])
        (cond
         [(eq? x (lhs a)) a]
         [else (lookup x (cdr env))]))])))

(define lookupo
  (lambda (x env t bound?)
    (conde
     [(== '() env) (== #f bound?)]
     [(fresh (y b rest)
        (== `((,y ,b) . ,rest) env)
        (conde
         [(== y x) (== #t bound?) (== b t)]
         [(=/= y x) (lookupo x rest t bound?)]))])))
\end{lstlisting}

So far so good: \code{lookup} only needs to add an input indicating whether the variable is bound; meanwhile for \code{lookup} we have to devise a special signal, namely \code{#f}, for the unbound case\footnote{There is technically a way to return multiple values in Scheme, but doing so would be lengthy and unconventional.}. However, a problem arises when we actually use the output signal:
\begin{lstlisting}
(define case1
  (lambda (x env)
    (cond
     [(lookup x env) => rhs]
     [else #f])))

(define case1o
  (lambda (x env out)
    (conde
     [(lookupo x env out #t)]
     [(lookupo x env 'unbound #f) (== #f out)])))
\end{lstlisting}

Why can we not use \code{else} in the second clause? The reason is that despite the similarity in appearance, \code{conde} does not process its clauses from top to bottom like \code{cond} does, so there can be no default case. As a result, programmers must always be prepared to append extra denials in lower \code{conde} clauses. This issue gets serious when the control flow is more complex:

\begin{lstlisting}
(define case2
  (lambda (x y env)
    (cond
     [(lookup x env) => rhs]
     [(lookup y env) => rhs]
     [else #f])))

(define case2o
  (lambda (x y env out)
    (conde
     [(lookupo x env out #t)]
     [(lookupo x env '? #f) (lookupo y env out #t)]
     [(lookupo x env '? #f) (lookupo y env '? #f)
      (== #f out)])))
\end{lstlisting}

The example above is still generous, as it is usual for relations to include four or more \code{conde} clauses. The number of extra denials exhibits quadratic growth, introducing opportunities for errors without any significant contribution to the meaning of the program. Fortunately, there is a simple way to deal with them using a technique inspired by \textcite{reif}. This solution relies on \textbf{pseudo-functions}.

\subsection{Pseudo-function and condo}
Pseudo-functions receive their results as arguments instead of returning them. To make sense of this concept, observe the following transformation (the "t" at the end denotes pseudo-functions, simply because it is too late to change):
\begin{lstlisting}
;; From function
(define bar (lambda (in) 'v))
;; To relation
(define baro (lambda (in out) (== out 'v)))
;; To pseudo-function...
(define bart (lambda (in) (lambda (out) (baro in out))))
;; ...which is equivalent to
(define bart (lambda (in) (lambda (out) (== out 'v))))
\end{lstlisting}

From a low-level point of view, a pseudo-function is a function which takes a single argument and return a goal. It can be seen that the act of returning values in functional programming is analogous to the act of unification in logic/relational programming. Moreover, a relation can be made to return whichever of its formal parameters, depending on the circumstances:
\begin{lstlisting}
;; From relation
(define conso (lambda (a d ls) (== `(,a . ,d) ls)))
;; To pseudo-function 1
(define cart (lambda (ls) (lambda (a) (fresh (d) (conso a d ls)))))
;; To pseudo-function 2
(define cdrt (lambda (ls) (lambda (d) (fresh (a) (conso a d ls)))))
;; To pseudo-function 3
(define const (lambda (a d) (lambda (ls) (conso a d ls))))
\end{lstlisting}
I have never encountered a situation where this is actually useful, since there is generally only one parameters deemed as the "output". It is worth noting that even though pseudo-functions act like pure functions, they can affect more than just the output. For instance, the goal \code{((cart x) a)} will always instantiate \code{x} to a pair if it is currently unknown.

Going back to the problem of conditionals, we first define two trivial pseudo-functions \code{truet} and \code{falset}, "returning" \code{#t} and \code{#f} respectively.

\begin{lstlisting}
(define truet (lambda () (lambda (?) (== #t ?))))
(define falset (lambda () (lambda (?) (== #f ?))))
\end{lstlisting}

Next, we define a single "primitive" pseudo-function similar to Scheme's \code{eq?}\footnote{Depending on the implementation, more primitive pseudo-functions may be defined using additional primitive constraints.}. This function relies on both \code{==} and \code{=/=} to correctly express two branches of the output.
\begin{lstlisting}
(define ==t
  (lambda (x y)
    (lambda (?)
      (conde
       [(== #t ?) (== x y)]
       [(== #f ?) (=/= x y)]))))
\end{lstlisting}

Next, we provide ways of creating more complex pseudo-functions from simpler ones, starting with \code{negt} (negation):
\begin{lstlisting}
(define negt
  (lambda (g)
    (lambda (?)
      (conde
       [(== #t ?) (g #f)]
       [(== #f ?) (g #t)]))))
\end{lstlisting}

From this, \code{=/=t} can be trivially derived:
\begin{lstlisting}
(define =/=t
  (lambda (x y) (negt (==t x y))))
\end{lstlisting}

Similarly, \code{conjt} (conjunction) and \code{disjt} (disjunction) are defined using macro:
\begin{lstlisting}
(define-syntax conjt
  (syntax-rules ()
    [(_) (truet)]
    [(_ g) g]
    [(_ g1 g2 gs ...)
     (lambda (?)
       (conde
        [(g1 #t) ((conjt g2 gs ...) ?)]
        [(== #f ?) (g1 #f)]))]))

(define-syntax disjt
  (syntax-rules ()
    [(_) (falset)]
    [(_ g) g]
    [(_ g1 g2 gs ...)
     (lambda (?)
       (conde
        [(== #t ?) (g1 #t)]
        [(g1 #f)  ((disjt g2 gs ...) ?)]))]))
\end{lstlisting}

This next example demonstrates conjunction:
\begin{lstlisting}
(run* (t x y z)
   ((conjt (==t x y)
           (==t y z))
    t))
\end{lstlisting}
$\Rightarrow$
\begin{lstlisting}
(((#f _.0 _.1 _.2) (=/= ((_.0 _.1))))
 (#t _.0 _.0 _.0)
 ((#f _.0 _.0 _.1) (=/= ((_.0 _.1)))))
\end{lstlisting}

Similarly, this example demonstrates disjunction:
\begin{lstlisting}
(run* (t x y z)
   ((disjt (==t x y)
           (==t y z))
    t))
\end{lstlisting}
$\Rightarrow$
\begin{lstlisting}
((#t _.0 _.0 _.1)
 ((#t _.0 _.1 _.1) (=/= ((_.0 _.1))))
 ((#f _.0 _.1 _.2) (=/= ((_.0 _.1)) ((_.1 _.2)))))
\end{lstlisting}

Finally, we can define the goal constructor \code{condo} -- the closest relational counterpart of \code{cond}. Keep in mind that \code{succeed} stands for the "do nothing" goal and \code{fail} stands for the "always fail" goal.
\begin{lstlisting}
(define-syntax condo
  (syntax-rules (else)
    [(_ [else]) succeed]
    [(_ [else g]) g]
    [(_ [else g1 g2 g* ...])
     (fresh () g1 g2 g* ...)]
    [(_ [test g* ...] c* ...)
     (conde
      [(test #t) g* ...]
      [(test #f) (condo c* ...)])]
    [(_) fail]))
\end{lstlisting}
\code{condo} is an interesting combinator because it uses two types of objects, pseudo-functions in the test positions and normal miniKanren goals in the bodies of each clause. The \code{else} keyword can be used to signify the default case; although it can be omitted, in which case the program fails when no clause matches. The example below demonstrates the use of \code{condo}:
\begin{lstlisting}
(run* (x y z)
  (condo
   [(==t x y) succeed]
   [(==t y z) succeed]
   [else (== x z)]))
\end{lstlisting}
$\Rightarrow$
\begin{lstlisting}
((_.0 _.0 _.1)
 ((_.0 _.1 _.1) (=/= ((_.0 _.1))))
 ((_.0 _.1 _.0) (=/= ((_.0 _.1)))))
\end{lstlisting}

We are now able to replace \code{lookupo} with the pseudo-function \code{lookupt}.
\begin{lstlisting}
(define lookupt
  (lambda (x env t)
    (lambda (bound?)
      (conde
       [(== '() env)
        (== #f bound?) (== t 'unbound)]
       [(fresh (y b rest)
          (== `((,y ,b) . ,rest) env)
          (condo
           [(==t y x) (== #t bound?) (== b t)]
           [else
            ((lookupt x rest t) bound?)]))]))))
\end{lstlisting}
Now the comparison between \code{case2} and \code{case2o} does not look so bad anymore.
\begin{lstlisting}
(define case2
  (lambda (x y env)
    (cond
     [(lookup x env) => rhs]
     [(lookup y env) => rhs]
     [else #f])))

(define case2o
  (lambda (x y env)
    (lambda (out)
      (condo
       [(lookupt x env out) succeed]
       [(lookupt y env out) succeed]
       [else (== #f out)]))))
\end{lstlisting}

Some readers may already be convinced to convert all of their relations to pseudo-functions. However, there are still some issues to address. Although hiding the control flow is great for readability, the downside is that there is no simple way to see what is done behind the layer of abstraction. As a result, it becomes easier to accidentally change the behavior of programs. Take for example this goal using \code{condo}:
\begin{lstlisting}
(fresh (x y)
  (condo
   [(==t 'a x) (== 'A y)]
   [(==t 'b x) (== 'B y)]
   [(==t 'c x) (== 'C y)]))
\end{lstlisting}
It is not clear that there is an issue with this code, because it looks so much like normal Scheme. The issue only shows itself when we expand the \code{condo}:
\begin{lstlisting}
(fresh (x y)
  (conde
   [(== 'a x) (== 'A y)]
   [(=/= 'a x) (== 'b x) (== 'B y)]
   [(=/= 'a x) (=/= 'b x) (== 'c x) (== 'C y)]))
\end{lstlisting}
Clearly, the additional denials in these \code{conde} clause are redundant since they are already mutually exclusive. Moreover, switching from \code{conde} to \code{condo} always means changing the way miniKanren's search work.

Reality has shown that serious miniKanren users who are conscious about their programs' behavior cannot afford \code{condo}, so we are once again stuck with lengthy, buggy \code{conde} clauses whose meaning cannot not be easily grasped. The next section addresses this issue by offering a way to verify the correctness of existing programs with \textbf{staticKanren}.